/*
Purpose: Photoshop Application that filters images
Authors:
1. Youssef Amgad Abd Al Halim Ahmed
Emails:
youssefamgadelkhatib@gmail.com
11410120230482@stud.cu.edu.eg

2. Amr Khaled Ahmed Abd Al Hamid Mohamed
Emails:
amr171516@gmail.com
11410120231116@stud.cu.edu.eg

3. Mohamed Ahmed Mohamed Abd Al Wahab
Emails:
ahmd.mohamed200515@gmail.com
11410120231134@stud.cu.edu.eg

system diagram link : https://drive.google.com/drive/folders/1hBaIyt5tXv7h1qtAeJwW8HEYiY32tMrz

GitHub repo link: https://github.com/mohamedahmed2005/Demo_photoshop-GUI
 */
#include <bits/stdc++.h>
#include "Image_Class.h"
#define ll long long
#define fast ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
using namespace std;

void purple(Image& primary,string& name);
void black_white(Image& primary, string &name);
void invert_image(Image& primary, string &name);
void flip(Image& primary, string &name);
void crop(Image& primary, string &name);
void rotate_image(Image& primary, string &name);
void grayscale_image(Image& primary, string &name);
void merge_image(Image& primary,string &name);
void lighten_darken_image(Image &primary, string&name);
void add_frame_to_image(Image& image,string& name);
void add_frame_arboretum(Image& image, int* frame_color,int* frame_color_2);
void add_frame_simple(Image& image, int* frame_color);
void circular_frame(Image& image,int *frame_color, int* frame_color_2);
void Infra_Red(Image& primary, string& name);
void resizing(Image& primary, string &name);
void detect_edge(Image& primary, string& name);
void blurImage(Image& primary,string& name);
void sunny_filter(Image& primary,string& name);
void oil_painting(Image& primary,string& name);
void TV(Image& image,string &name);
void resize2_image(int new_width ,int new_height,Image& image);
void filter_choices(string filter_choice, Image& primary, string &name);
void filters_menu(Image & primary, string &name);
void asking_for_saving(Image& primary, string &name);
void save_image(Image& primary,string& name);
void load_image(Image& primary, string& name);
void Cardiod(Image& image2,string &name);
void center_light(Image& image,string & name);
void rotate_frame(Image& image, string &name);
string valid_choice(string filter_choice);
string image_name_validate(string name,string& Image_name);
string choice_load_save(string choice);
string choice_load_save_2(string choice);
bool is_number(string x);
bool validate_center_light(float num);
void Ball(Image& primary,string &name);
void Pixelate(Image& primary,string &name);
void Egg(Image& primary,string &name);
int square(int x);
void rain_drop(Image& image, string& name);
void skew(Image& image,string& name);
float getValidFloatInput();
bool validate_rotate_frame(float num);

//void test(){
//    Image image("toy1.jpg");
//    float ang;cin>>ang;
//    bool isLikeSquareAt45= false;
//    if(ang>40||ang<-40)
//        isLikeSquareAt45=true;
//
//    if(image.width>image.height && ang) {
//        if (ang > 0) {
//            ang = ang * 3.1415927 / 180;
//            float cosA = cos(ang);
//            float sinA = sin(ang);
//            int y = image.width * sin(ang);
//            if (isLikeSquareAt45)
//                y *= 0.68;
//            float slope = tan(ang);
//            float slope2 = -1 / slope;
//            int xs = (slope * y + image.height - slope * image.width + slope2 * y) / (slope2 - slope);
//            int ys = slope * (xs - image.width + y) + image.height;
//            Image image2(sqrt(pow(xs - image.width + y, 2) + pow(ys - image.height, 2)),
//                         sqrt(pow(y - xs, 2) + ys * ys));
//
//            int af, ag;
//            for (int i = 0; i < image2.width; ++i) {
//                for (int j = 0; j < image2.height; ++j) {
//                    ag = y + i * cosA - j * sinA;
//                    ag = image.width - ag;
//                    af = sinA * (i - slope * j) + j / cosA;
//                    image2(image2.width - i, j, 0) = image(ag, af, 0);
//                    image2(image2.width - i, j, 1) = image(ag, af, 1);
//                    image2(image2.width - i, j, 2) = image(ag, af, 2);
//                }
//            }
//            string nameImage =
//                    "RotateWid5_" + to_string(int((ang * 180 / 3.1415927))) + "__" + to_string(image2.width) + "x" +
//                    to_string(image2.height) + ".jpg";
//            image2.saveImage(nameImage);
//            system(nameImage.c_str());
//        } else if (ang < 0) {
//            ang = -ang * 3.1415927 / 180;
//            float cosA = cos(ang);
//            float sinA = sin(ang);
//            int y = image.width * sin(ang);
//            if (isLikeSquareAt45)
//                y *= 0.68;
//            float slope = tan(ang);
//            float slope2 = -1 / slope;
//            int xs = (slope * y + image.height - slope * image.width + slope2 * y) / (slope2 - slope);
//            int ys = slope * (xs - image.width + y) + image.height;
//            Image image2(sqrt(pow(xs - image.width + y, 2) + pow(ys - image.height, 2)),
//                         sqrt(pow(y - xs, 2) + ys * ys));
//            cout << "image2.width = " << image2.width << "\timage2.height = " << image2.height << '\n';
//            int ag, af;
//            for (int i = 0; i < image2.width; ++i) {
//                for (int j = 0; j < image2.height; ++j) {
//                    ag = y + i * cosA - j * sinA;
//                    af = sinA * (i - slope * j) + j / cosA;
//                    image2(i, j, 0) = image(ag, af, 0);
//                    image2(i, j, 1) = image(ag, af, 1);
//                    image2(i, j, 2) = image(ag, af, 2);
//                }
//            }
//            string nameImage =
//                    "RotateWid5_" + to_string(-int((ang * 180 / 3.1415927))) + "__" + to_string(image2.width) + "x" +
//                    to_string(image2.height) + ".jpg";
//            image2.saveImage(nameImage);
//            system(nameImage.c_str());
//        }
//    }
//    exit(0);
//}

int main() {
    fast
    // welcome user and ask him to load the primary via name and extension
    cout<<"Welcome to our primary filters application"<<endl<<endl;
    cout<<"Load your primary"<<endl;
    cout<<"Enter your primary name with a correct extension"<<endl;
    cout<<".jpg or .bmp or .png or .jpeg: "<<endl;
    string image_name;
    getline(cin,image_name);
    Image primary;

    // make sure that the primary is in the directory
    while(true){
        try{
            primary.loadNewImage(image_name);
            cout<<"Loaded successfully"<<endl;
            cout<<endl;
            break;

        }
        catch(const invalid_argument& e) {
            cout<<"Enter a correct primary name with correct extension"<<endl;
            cout<<".jpg or .bmp or .png or .jpeg"<<endl;
            getline(cin,image_name);
        }
    }
    filters_menu(primary, image_name);




}


// function that calls filter function according to user's choice
void filter_choices(string filter_choice, Image& primary, string &name){
    if (filter_choice == "1") {
        grayscale_image(primary,name);
    }
    else if (filter_choice == "2") {
        black_white(primary,name);
    }
    else if (filter_choice == "3") {
        invert_image(primary,name);
    }
    else if(filter_choice=="4"){
        merge_image(primary,name);
    }
    else if(filter_choice=="5"){
        flip(primary,name);
    }
    else if (filter_choice == "6") {
        rotate_image(primary,name);
    }
    else if(filter_choice=="7"){
        lighten_darken_image(primary,name);
    }
    else if(filter_choice=="8"){
        crop(primary,name);
    }
    else if(filter_choice=="9"){
        add_frame_to_image(primary,name);
    }
    else if(filter_choice=="10"){
        detect_edge(primary,name);
    }
    else if (filter_choice == "11"){
        resizing(primary, name);
    }
    else if(filter_choice=="12"){
        Infra_Red(primary,name);
    }
    else if(filter_choice=="13"){
        purple(primary,name);
    }
    else if(filter_choice=="14"){
        blurImage(primary,name);
    }
    else if(filter_choice=="15"){
        sunny_filter(primary,name);
    }
    else if(filter_choice=="16"){
        Ball(primary,name);
    }
    else if(filter_choice=="17"){
        Pixelate(primary,name);
    }
    else if(filter_choice=="18"){
        rain_drop(primary,name);
    }
    else if(filter_choice=="19"){
        skew(primary,name);
    }
    else if(filter_choice=="20"){
        oil_painting(primary,name);
    }
    else if(filter_choice=="21"){
        Egg(primary,name);
    }
    else if(filter_choice=="22"){
        Cardiod(primary,name);
    }
    else if(filter_choice=="23"){
        center_light(primary,name);
    }
    else if(filter_choice=="24"){
        rotate_frame(primary,name);
    }
    else if(filter_choice=="25"){
        TV(primary,name);
    }
    else if (filter_choice == "26"){
        load_image(primary,name);
    }
    else if(filter_choice=="27"){
        save_image(primary,name);
        filters_menu(primary,name);
    }
    else if(filter_choice=="28"){
        save_image(primary,name);
        cout<<"Thanks for using our primary filters application"<<endl;
        exit(0);
    }
}

// function that validates filter_choice
string valid_choice(string filter_choice){
    while(true){
        if(filter_choice == "1")break;
        else if(filter_choice == "2")break;
        else if(filter_choice == "3")break;
        else if(filter_choice == "4")break;
        else if(filter_choice == "5")break;
        else if(filter_choice == "6")break;
        else if(filter_choice == "7")break;
        else if(filter_choice == "8")break;
        else if(filter_choice == "9")break;
        else if(filter_choice == "10")break;
        else if(filter_choice == "11")break;
        else if(filter_choice == "12")break;
        else if(filter_choice == "13")break;
        else if(filter_choice == "14")break;
        else if(filter_choice == "15")break;
        else if(filter_choice == "16")break;
        else if(filter_choice == "17")break;
        else if(filter_choice == "18")break;
        else if(filter_choice == "19")break;
        else if(filter_choice == "20")break;
        else if(filter_choice == "21")break;
        else if(filter_choice == "22")break;
        else if(filter_choice == "23")break;
        else if(filter_choice == "24")break;
        else if(filter_choice == "25")break;
        else if(filter_choice == "26")break;
        else if(filter_choice == "27")break;
        else if(filter_choice == "28")break;
        else{
            cout<<"Please enter a valid choice"<<endl;
            cin>>filter_choice;
        }
    }
    return filter_choice;
}

// function that validates if entered primary name has a correct extension
string image_name_validate(string name, string & Image_name){
    if(name==Image_name){
        cout<<"Please enter a correct name with a correct extension: "<<endl;
        cin>>name;
        return image_name_validate(name,Image_name);
    }
    while(true){
        if(name.length()-4 >0 && name[name.length()-1]=='p' && name[name.length()-2]=='m' && name[name.length()-3]=='b' && name[name.length()-4]=='.'){
            return name;
        }
        else if(name.length()-4 >0  &&name[name.length()-1]=='g' && name[name.length()-2]=='p' && name[name.length()-3]=='j' && name[name.length()-4]=='.'){
            return name;
        }
        else if(name.length()-4 >0  &&name[name.length()-1]=='g' && name[name.length()-2]=='n' && name[name.length()-3]=='p' && name[name.length()-4]=='.'){
            return name;
        }
        else if(name.length()-5 >0  &&name[name.length()-1]=='g' && name[name.length()-2]=='e' && name[name.length()-3]=='p' && name[name.length()-4]=='j' && name[name.length()-5]=='.'){
            return name;
        }
        else{
            cout<<"Please enter a correct name with a correct extension: "<<endl;
            cin>>name;
            return image_name_validate(name, Image_name);
        }
    }

}

void filters_menu(Image & primary, string &name){
    // print out filter options for user
    cout<<"1.  Grayscale"<<endl;
    cout<<"2.  Black and White filter" << endl;
    cout<<"3.  Invert primary"<<endl;
    cout<<"4.  Merge two images"<<endl;
    cout<<"5.  Flip an primary"<<endl;
    cout<<"6.  Rotate primary"<<endl;
    cout<<"7.  Darken and Lighten Image"<<endl;
    cout<<"8.  Crop an primary"<<endl;
    cout<<"9.  Adding frame"<<endl;
    cout<<"10. Detect Edge"<<endl;
    cout<<"11. Resizing"<<endl;
    cout<<"12. Infra_Red"<<endl;
    cout<<"13. Purple Filter" << endl;
    cout<<"14. Blur primary" <<endl;
    cout<<"15. sunny filter" <<endl;
    cout<<"16. Ball filter"<<endl;
    cout<<"17. Pixelate filter"<<endl;
    cout<<"18. Rain Drop filter"<<endl;
    cout<<"19. Skew filter"<<endl;
    cout<<"20. Oil painting"<<endl;
    cout<<"21. Egg filter"<<endl;
    cout<<"22. Heart filter"<<endl;
    cout<<"23. Center light"<<endl;
    cout<<"24. Rotate frame"<<endl;
    cout<<"25. TV"<<endl;
    cout<<"26. Load a new primary image"<<endl;
    cout<<"27. Save the Image"<<endl;
    cout<<"28. Exit"<<endl<<endl;
    cout<<"Please enter your filter choice: "<<endl;
    string filter_choice;
    cin>>filter_choice;

    // validate filter choice and do the filter according to the choice of the user
    filter_choice=valid_choice(filter_choice);
    filter_choices(filter_choice,primary,name);
}

// function that validates load or save choice
string choice_load_save(string choice){
    while(true){
        if(choice=="1")return choice;
        else if(choice=="2")return choice;
        else{
            cout<<"Please enter a correct choice: "<<endl;
            cin>>choice;
        }
    }
}

string choice_load_save_2(string choice){
    while(true){
        if(choice=="1")return choice;
        else if(choice=="2")return choice;
        else if(choice=="3")return choice;
        else if(choice=="4")return choice;

        else{
            cout<<"Please enter a correct choice: "<<endl;
            cin>>choice;
        }
    }
}



void invert_image(Image& primary, string &name) {
    for (int i = 0; i < primary.width; i++) {
        for (int j = 0; j < primary.height; j++) {
            for (int k = 0; k < primary.channels; k++) {
                primary(i, j, k) = 255 - primary(i, j, k);
            }
        }
    }
    asking_for_saving(primary, name);
}


void rotate_image( Image& primary, string &name) {
    Image rotated_image(primary.height, primary.width); // declare this photo to 90-degree photo
    string x,y;
    cout<<"1: rotate by 90 degree"<<endl;
    cout<<"2: rotate by 180 degree"<<endl;
    cout<<"3: rotate by 270 degree"<<endl;
    cout<<"Enter your choice between 1&2&3: "<<endl;
    cin>>x;
    while(x!="1"&&x!="2"&&x!="3"){
        cout<<"invalid choice\n";
        cout<<"Enter your choice between 1&2&3: "<<endl;
        cin>>x;
    }
    cout<<"1: begin rotation from right: "<<endl;
    cout<<"2: begin rotation from left: "<<endl;
    cout<<"Choose between 1&2: "<<endl;
    cin>>y;
    while(y!="1"&&y!="2"){
        cout<<"invalid choice"<<endl;
        cout<<"1: begin rotation from left: "<<endl;
        cout<<"2: begin rotation from right: "<<endl;
        cout<<"Choose between 1&2: "<<endl;
        cin>>y;
    }
    if(y=="1"){ // check to begin from left
        if(x=="1"){
            for (int i = 0; i < primary.width; i++) {
                for (int j = 0; j < primary.height; j++) {
                    rotated_image(j, primary.width - 1 - i, 0) = primary(i, j, 0); //j represents the row index || primary.width - 1 - i represents the new column index on matrix for red color
                    rotated_image(j, primary.width - 1 - i, 1) = primary(i, j, 1); //j represents the row index || primary.width - 1 - i represents the new column index on matrix for green color
                    rotated_image(j, primary.width - 1 - i, 2) = primary(i, j, 2); //j represents the row index || primary.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            asking_for_saving(rotated_image, name);
        }
        else if (x == "2") {
            for (int i = 0; i < primary.width; i++) {
                for (int j = 0; j < primary.height; j++) {
                    rotated_image(j, primary.width - 1 - i, 0) = primary(i, j, 0); //j represents the row index || primary.width - 1 - i represents the new column on matrix for red color
                    rotated_image(j, primary.width - 1 - i, 1) = primary(i, j, 1); //j represents the row index || primary.width - 1 - i represents the new column on matrix for green color
                    rotated_image(j, primary.width - 1 - i, 2) = primary(i, j, 2); //j represents the row index || primary.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            Image rotated_image_2(rotated_image.height, rotated_image.width); // declare this photo that will be 180-degree photo
            for (int i = 0; i < rotated_image.width; i++) {
                for (int j = 0; j < rotated_image.height; j++) {
                    rotated_image_2(j, rotated_image.width - 1 - i, 0) = rotated_image(i, j, 0); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for red color
                    rotated_image_2(j, rotated_image.width - 1 - i, 1) = rotated_image(i, j, 1); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for green color
                    rotated_image_2(j, rotated_image.width - 1 - i, 2) = rotated_image(i, j, 2); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for blue color
                }
            }

            asking_for_saving(rotated_image_2, name);
        }
        else if(x=="3"){
            for (int i = 0; i < primary.width; i++) {
                for (int j = 0; j < primary.height; j++) {
                    rotated_image(j, primary.width - 1 - i, 0) = primary(i, j, 0);  //j represents the row index || primary.width - 1 - i represents the new column index on matrix for red color
                    rotated_image(j, primary.width - 1 - i, 1) = primary(i, j, 1);  //j represents the row index || primary.width - 1 - i represents the new column index on matrix for green color
                    rotated_image(j, primary.width - 1 - i, 2) = primary(i, j, 2);  //j represents the row index || primary.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            Image rotated_image_2(rotated_image.height, rotated_image.width);
            for (int i = 0; i < rotated_image.width; i++) {
                for (int j = 0; j < rotated_image.height; j++) {
                    rotated_image_2(j, rotated_image.width - 1 - i, 0) = rotated_image(i, j, 0); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for red color
                    rotated_image_2(j, rotated_image.width - 1 - i, 1) = rotated_image(i, j, 1); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for green color
                    rotated_image_2(j, rotated_image.width - 1 - i, 2) = rotated_image(i, j, 2); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            Image rotated_image_3(rotated_image_2.height, rotated_image_2.width); // declare this photo that will be 270-degree photo
            for (int i = 0; i < rotated_image_2.width; i++) {
                for (int j = 0; j < rotated_image_2.height; j++) {
                    rotated_image_3(j, rotated_image_2.width - 1 - i, 0) = rotated_image_2(i, j, 0); //j represents the row index || rotated_image_2.width - 1 - i represents the new column index on matrix for red color
                    rotated_image_3(j, rotated_image_2.width - 1 - i, 1) = rotated_image_2(i, j, 1); //j represents the row index || rotated_image_2.width - 1 - i represents the new column index on matrix for green color
                    rotated_image_3(j, rotated_image_2.width - 1 - i, 2) = rotated_image_2(i, j, 2); //j represents the row index || rotated_image_2.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            asking_for_saving(rotated_image_3, name);
        }
    }
    if(y=="2"){ // check to begin from right
        if(x=="1"){
            for (int i = 0; i < primary.width; i++) {
                for (int j = 0; j < primary.height; j++) {
                    rotated_image(j, primary.width - 1 - i, 0) = primary(i, j, 0);  //j represents the row index || primary.width - 1 - i represents the new column index on matrix for red color
                    rotated_image(j, primary.width - 1 - i, 1) = primary(i, j, 1);  //j represents the row index || primary.width - 1 - i represents the new column index on matrix for green color
                    rotated_image(j, primary.width - 1 - i, 2) = primary(i, j, 2);  //j represents the row index || primary.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            Image rotated_image_2(rotated_image.height, rotated_image.width);
            for (int i = 0; i < rotated_image.width; i++) {
                for (int j = 0; j < rotated_image.height; j++) {
                    rotated_image_2(j, rotated_image.width - 1 - i, 0) = rotated_image(i, j, 0); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for red color
                    rotated_image_2(j, rotated_image.width - 1 - i, 1) = rotated_image(i, j, 1); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for green color
                    rotated_image_2(j, rotated_image.width - 1 - i, 2) = rotated_image(i, j, 2); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            Image rotated_image_3(rotated_image_2.height, rotated_image_2.width); // declare this photo that will be 270-degree photo
            for (int i = 0; i < rotated_image_2.width; i++) {
                for (int j = 0; j < rotated_image_2.height; j++) {
                    rotated_image_3(j, rotated_image_2.width - 1 - i, 0) = rotated_image_2(i, j, 0); //j represents the row index || rotated_image_2.width - 1 - i represents the new column index on matrix for red color
                    rotated_image_3(j, rotated_image_2.width - 1 - i, 1) = rotated_image_2(i, j, 1); //j represents the row index || rotated_image_2.width - 1 - i represents the new column index on matrix for green color
                    rotated_image_3(j, rotated_image_2.width - 1 - i, 2) = rotated_image_2(i, j, 2); //j represents the row index || rotated_image_2.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            asking_for_saving(rotated_image_3, name);
        }
        if(x=="2"){
            for (int i = 0; i < primary.width; i++) {
                for (int j = 0; j < primary.height; j++) {
                    rotated_image(j, primary.width - 1 - i, 0) = primary(i, j, 0); //j represents the row index || primary.width - 1 - i represents the new column on matrix for red color
                    rotated_image(j, primary.width - 1 - i, 1) = primary(i, j, 1); //j represents the row index || primary.width - 1 - i represents the new column on matrix for green color
                    rotated_image(j, primary.width - 1 - i, 2) = primary(i, j, 2); //j represents the row index || primary.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            Image rotated_image_2(rotated_image.height, rotated_image.width); // declare this photo that will be 180-degree photo
            for (int i = 0; i < rotated_image.width; i++) {
                for (int j = 0; j < rotated_image.height; j++) {
                    rotated_image_2(j, rotated_image.width - 1 - i, 0) = rotated_image(i, j, 0); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for red color
                    rotated_image_2(j, rotated_image.width - 1 - i, 1) = rotated_image(i, j, 1); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for green color
                    rotated_image_2(j, rotated_image.width - 1 - i, 2) = rotated_image(i, j, 2); //j represents the row index || rotated_image.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            asking_for_saving(rotated_image_2, name);
        }
        if(x=="3"){
            for (int i = 0; i < primary.width; i++) {
                for (int j = 0; j < primary.height; j++) {
                    rotated_image(j, primary.width - 1 - i, 0) = primary(i, j, 0); //j represents the row index || primary.width - 1 - i represents the new column index on matrix for red color
                    rotated_image(j, primary.width - 1 - i, 1) = primary(i, j, 1); //j represents the row index || primary.width - 1 - i represents the new column index on matrix for green color
                    rotated_image(j, primary.width - 1 - i, 2) = primary(i, j, 2); //j represents the row index || primary.width - 1 - i represents the new column index on matrix for blue color
                }
            }
            asking_for_saving(rotated_image, name);
        }
    }
}
void merge_image(Image& primary,string &name){
    cin.ignore();
    cout<<"Please load your second primary"<<endl;
    cout<<"Enter your primary name with a correct extension"<<endl;
    cout<<".jpg or .bmp or .png or .jpeg: "<<endl;
    string image_name;
    getline(cin,image_name);
    Image secondary;
    // make sure that the primary is in the directory
    while(true){
        try{
            secondary.loadNewImage(image_name);
            cout<<"Loaded successfully"<<endl;
            cout<<endl;
            break;

        }
        catch(const invalid_argument& e) {
            cout<<"Enter a correct primary name with correct extension"<<endl;
            cout<<".jpg or .bmp or .png or .jpeg"<<endl;
            getline(cin,image_name);
        }
    }

    cout<<"1. Resize on smaller dimensions"<<endl;
    cout<<"2. Resize on bigger dimensions"<<endl;
    string choice;
    cin>>choice;
    while(true){
        if(choice=="1")break;
        else if(choice=="2")break;
        else{
            cout<<"Please enter a valid choice"<<endl;
            cin>>choice;
        }
    }

    if(choice=="1"){
        // Determining smaller dimensions
        int width;
        int height;
        if(primary.width<=secondary.width){
            width=primary.width;
        }
        else{
            width=secondary.width;
        }
        if(primary.height<=secondary.height){
            height=primary.height;
        }
        else{
            height=secondary.height;
        }

        Image thirdly(width,height);
        for(int i=0; i<thirdly.width; i++){
            for(int j=0; j<thirdly.height; j++){
                for(int k=0; k<thirdly.channels; k++){
                    int avg=(primary(i,j,k)+secondary(i,j,k))/2;
                    if(avg>=255){
                        if(primary(i,j,k)>=secondary(i,j,k)){
                            thirdly(i,j,k)=primary(i,j,k);
                        }
                        else{
                            thirdly(i,j,k)=secondary(i,j,k);
                        }
                    }
                    else{
                        thirdly(i,j,k)=avg;
                    }
                }

            }
        }
        asking_for_saving(thirdly,name);
    }
    else if(choice=="2"){
        // resizing smaller primary to bigger dimensions if its height and width are both smaller than second primary
        if(primary.width<=secondary.width && primary.height<=secondary.height){
            // declare the resizing variables
            int width_scale=secondary.width;
            int height_scale=secondary.height;
            double h = (height_scale/1.0)/(primary.height/1.0) ,w = (width_scale/1.0)/(primary.width/1.0);

            // get the new primary depend on the scale input
            Image after ( width_scale, height_scale);

            // this loop use to get the new primary by resizing the old one
            for(int i = 0 ; i < width_scale ; i++){
                for(int j = 0 ; j < height_scale ; j++){
                    after(i,j,0) = primary(i/w,j/h,0);
                    after(i,j,1) = primary(i/w,j/h,1);
                    after(i,j,2) = primary(i/w,j/h,2);

                }
            }


            // taking the average of two pixels and making the third primary equal that
            Image thirdly(after.width, after.height);

            for(int i=0; i<thirdly.width; i++){
                for(int j=0; j<thirdly.height; j++){
                    for(int k=0; k<thirdly.channels; k++){
                        int avg=(after(i,j,k)+secondary(i,j,k))/2;
                        if(avg>=255){
                            if(after(i,j,k)>=secondary(i,j,k)){
                                thirdly(i,j,k)=after(i,j,k);
                            }
                            else{
                                thirdly(i,j,k)=secondary(i,j,k);
                            }
                        }
                        else{
                            thirdly(i,j,k)=avg;
                        }
                    }

                }
            }
            asking_for_saving(thirdly,name);
        }
            // same thing but for the second primary
        else if(secondary.width<=primary.width && secondary.height<= primary.height){
            // declare the resizing variables
            int width_scale=primary.width;
            int height_scale=primary.height;
            double h = (height_scale/1.0)/(secondary.height/1.0) ,w = (width_scale/1.0)/(secondary.width/1.0);

            // get the new primary depend on the scale input
            Image after ( width_scale, height_scale);

            // this loop use to get the new primary by resizing the old one
            for(int i = 0 ; i < width_scale ; i++){
                for(int j = 0 ; j < height_scale ; j++){
                    after(i,j,0) = secondary(i/w,j/h,0);
                    after(i,j,1) = secondary(i/w,j/h,1);
                    after(i,j,2) = secondary(i/w,j/h,2);

                }
            }



            Image thirdly(after.width, after.height);

            for(int i=0; i<thirdly.width; i++){
                for(int j=0; j<thirdly.height; j++){
                    for(int k=0; k<thirdly.channels; k++){
                        int avg=(after(i,j,k)+primary(i,j,k))/2;
                        if(avg>=255){
                            if(after(i,j,k)>=primary(i,j,k)){
                                thirdly(i,j,k)=after(i,j,k);
                            }
                            else{
                                thirdly(i,j,k)=primary(i,j,k);
                            }
                        }
                        else{
                            thirdly(i,j,k)=avg;
                        }
                    }

                }
            }
            asking_for_saving(thirdly,name);
        }
            // if width of first primary is less than second, but it has bigger height
        else if(primary.width<=secondary.width && primary.height>=secondary.height){
            // declare the resizing variables
            int width_scale=secondary.width;
            int height_scale=primary.height;
            double h = (height_scale/1.0)/(secondary.height/1.0) ,w = (width_scale/1.0)/(primary.width/1.0);

            // make first primary bigger in width
            Image after ( width_scale, height_scale);

            // this loop use to get the new primary by resizing the old one
            for(int i = 0 ; i < width_scale ; i++){
                for(int j = 0 ; j < height_scale ; j++){
                    after(i,j,0) = primary(i/w,j,0);
                    after(i,j,1) = primary(i/w,j,1);
                    after(i,j,2) = primary(i/w,j,2);

                }
            }
            // making second primary height bigger
            Image after_2(width_scale,height_scale);
            for(int i = 0 ; i < width_scale ; i++){
                for(int j = 0 ; j < height_scale ; j++){
                    after_2(i,j,0) = secondary(i,j/h,0);
                    after_2(i,j,1) = secondary(i,j/h,1);
                    after_2(i,j,2) = secondary(i,j/h,2);

                }
            }



            Image thirdly(after.width, after.height);

            for(int i=0; i<thirdly.width; i++){
                for(int j=0; j<thirdly.height; j++){
                    for(int k=0; k<thirdly.channels; k++){
                        int avg=(after(i,j,k)+after_2(i,j,k))/2;
                        if(avg>=255){
                            if(after(i,j,k)>=after_2(i,j,k)){
                                thirdly(i,j,k)=after(i,j,k);
                            }
                            else{
                                thirdly(i,j,k)=after_2(i,j,k);
                            }
                        }
                        else{
                            thirdly(i,j,k)=avg;
                        }
                    }

                }
            }
            asking_for_saving(thirdly,name);
        }
        else if(secondary.width<=primary.width && secondary.height>=primary.height){
            // declare the resizing variables
            int width_scale=primary.width;
            int height_scale=secondary.height;
            double h = (height_scale/1.0)/(primary.height/1.0) ,w = (width_scale/1.0)/(secondary.width/1.0);

            // making first primary height bigger
            Image after ( width_scale, height_scale);

            // this loop use to get the new primary by resizing the old one
            for(int i = 0 ; i < width_scale ; i++){
                for(int j = 0 ; j < height_scale ; j++){
                    after(i,j,0) = primary(i,j/h,0);
                    after(i,j,1) = primary(i,j/h,1);
                    after(i,j,2) = primary(i,j/h,2);

                }
            }
            // making second primary width bigger
            Image after_2(width_scale,height_scale);
            for(int i = 0 ; i < width_scale ; i++){
                for(int j = 0 ; j < height_scale ; j++){
                    after_2(i,j,0) = secondary(i/w,j,0);
                    after_2(i,j,1) = secondary(i/w,j,1);
                    after_2(i,j,2) = secondary(i/w,j,2);

                }
            }



            Image thirdly(after.width, after.height);

            for(int i=0; i<thirdly.width; i++){
                for(int j=0; j<thirdly.height; j++){
                    for(int k=0; k<thirdly.channels; k++){
                        int avg=(after(i,j,k)+after_2(i,j,k))/2;
                        if(avg>=255){
                            if(after(i,j,k)>=after_2(i,j,k)){
                                thirdly(i,j,k)=after(i,j,k);
                            }
                            else{
                                thirdly(i,j,k)=after_2(i,j,k);
                            }
                        }
                        else{
                            thirdly(i,j,k)=avg;
                        }
                    }

                }
            }
            asking_for_saving(thirdly,name);
        }
    }

}

void Infra_Red(Image& primary, string& name){
    // loop on each pixel, make G and B colours=255-original Red colour then make New Red color=255
    for(int i=0; i<primary.width; i++){
        for(int j=0; j<primary.height; j++){
            primary(i,j,1)=255-primary(i,j,0);
            primary(i,j,2)=255-primary(i,j,0);
            primary(i,j,0)=255;
        }
    }
    asking_for_saving(primary, name);
}

void lighten_darken_image(Image &primary, string&name){
    cout<<"1. Lighten Image"<<endl;
    cout<<"2. Darken Image"<<endl;
    cout<<"Enter 1 or 2"<<endl;
    string filter_choice;
    cin>>filter_choice;
    filter_choice=choice_load_save(filter_choice);
    cout<<"Enter percentage from 1 to 100"<<endl;
    string percent;
    cin>>percent;
    while(true){
        if(!is_number(percent)|| stoi(percent)>100 || stoi(percent)<1){
            cout<<"please enter a valid percent"<<endl;
            cin>>percent;
        }
        else{
            break;
        }
    }
    double change=stoi(percent);

    change=100/change;


    // add percentage chosen of the pixel colour to the pixel colour to lighten primary
    if(filter_choice=="1"){
        for(int i=0; i<primary.width; i++){
            for(int j=0; j<primary.height; j++){
                for(int k=0; k<primary.channels; k++){
                    if(primary(i,j,k)+primary(i,j,k)/change>255){
                        primary(i,j,k)=255;
                    }
                    else{
                        primary(i,j,k)+=primary(i,j,k)/change;
                    }
                }
            }
        }
    }
        // decrease pixel colour to percentage chosen pixel colour
    else if(filter_choice=="2"){
        for(int i=0; i<primary.width; i++){
            for(int j=0; j<primary.height; j++){
                for(int k=0; k<primary.channels; k++){
                    primary(i,j,k)-=primary(i,j,k)/change;
                }
            }
        }
    }
    asking_for_saving(primary, name);

}

void grayscale_image(Image& primary, string &name){
    // loop on each pixel, calculate average of RGB and make each pixel equal that average
    for(int i=0; i<primary.width; i++){
        for(int j=0; j<primary.height; j++){
            unsigned int avg=0;
            avg+=primary(i,j,0);
            avg+=primary(i,j,1);
            avg+=primary(i,j,2);
            avg=avg/3;
            primary(i,j,0)=avg;
            primary(i,j,1)=avg;
            primary(i,j,2)=avg;
        }
    }

    asking_for_saving(primary, name);

}


void black_white(Image& primary, string &name){
    // if the pixel channel color was under 127 make it 0 else make it 255
    int avg = 0;
    for(int i=0; i<primary.width; i++){
        for(int j=0; j<primary.height; j++){
            for (int k = 0 ; k < primary.channels ; k++){
                avg =+ primary(i,j,k);
            }
            avg = avg%256;
            if(avg > 128){
                primary(i,j,0) = 255;
                primary(i,j,1) = 255;
                primary(i,j,2) = 255;

            }else{
                primary(i,j,0) = 0;
                primary(i,j,1) = 0;
                primary(i,j,2) = 0;

            }
        }
    }

    asking_for_saving(primary, name);

}


void resizing(Image& primary, string &name){
    /*
     * 1 --> declare a new primary to store the old after resize
     * 2 --> declare pattern to validate on it
     * 3 --> declare matches to get the height and the width individually then turn them into integer
     * 4 --> get the width scale and the height scale by the old primary height and width
     * 5 --> or make it by the ratio
     * 6 --> resize
     * */
    string choice;
    do{
        cout << "Please select\n1 to resize by ratio\n2 to resize by dimensions" << endl;
        cin >> choice;
        if(!(choice  == "2" || choice == "1")){cout << "Invalid input" << endl;}
    }while (!(choice  == "2" || choice == "1"));

    if (choice == "2"){// Declare variables for the scale and dimensions
        string scale;
        int ht, wd;
        smatch matches;

// Define a regex pattern for matching the scale format (width*height)
        regex pattern(R"((\d+)\*(\d+))");

// Use a do-while loop to repeatedly prompt the user for input until a valid scale is entered
        int width_scale, height_scale;
        cin.ignore();

        do {
            // Prompt the user to enter the scale
            cout << "Enter the size you want in (format: width*height):" << endl;
            getline(cin,scale);


            // Check if the input matches the regex pattern
            if (!regex_search(scale, matches, pattern)) {
                // If the input does not match the pattern, print an error message and continue the loop
                cout << "Invalid input format" << endl;
                continue;
            }

            // Extract the width and height substrings from the input
            width_scale = stoi(matches[1]);
            height_scale = stoi(matches[2]);

            // Check if the width and height scale factors are positive integers
            if (width_scale <= 0 || height_scale <= 0) {
                // If the width or height scale factor is not a positive integer, print an error message
                cout << "Invalid input: width and height must be positive integers" << endl;
            }

            if (width_scale > 20000 || height_scale > 20000) {
                cout<< "This would be an excessive change in size and would be impossible to formulate currently or would take too much time. Please enter a smaller size"<< endl;
                continue;
            }

            // Continue the loop until a valid scale is entered
        } while (!(regex_search(scale, matches, pattern) && width_scale > 0 && height_scale > 0) ||
                 width_scale > 20000 || height_scale > 20000);

        // Use the width and height scale factors
        // declare the resizing variables
        double h = (height_scale / 1.0) / (primary.height / 1.0), w = (width_scale / 1.0) / (primary.width / 1.0);

        // get the new primary depend on the scale input
        Image after(width_scale, height_scale);

        // this loop use to get the new primary by resizing the old one
        for (int i = 0; i < after.width; i++) {
            for (int j = 0; j < after.height; j++) {
                after(i, j, 0) = primary(i / w, j / h, 0);
                after(i, j, 1) = primary(i / w, j / h, 1);
                after(i, j, 2) = primary(i / w, j / h, 2);

            }
        }


        asking_for_saving(after, name);
    }else{

        regex pattern(R"((\d+)\:(\d+))");
        string ratio;
        smatch matches;
        double ratio_d;
        cin.ignore();
        do{
            // Prompt the user to enter the scale
            cout << "Enter the ratio you want in (format--> num1:num2):" << endl;

            getline(cin,ratio);
            // Check if the input matches the regex pattern
            if (!regex_search(ratio, matches, pattern)) {
                // If the input does not match the pattern, print an error message and continue the loop
                cout << "Invalid input format" << endl;
                continue;
            }
            // Extract the ratio and transform ir into double

            regex_search(ratio, matches, pattern);
            ratio_d = stod(matches[1])/stod(matches[2]);
            if((primary.width * ratio_d) > 20000 || (primary.width * ratio_d) < 10 || (primary.height * ratio_d) > 20000 || (primary.height * ratio_d) < 10 ){
                cout << "Sorry but this is out of the range" << endl;
            }

        }while(!regex_search(ratio, matches, pattern) || ratio_d == 0 || matches[2] == "0" ||
               (primary.width * ratio_d) > 20000 || (primary.width * ratio_d) < 10 || (primary.height * ratio_d) > 20000 || (primary.height * ratio_d) < 10 );


        // get the new primary the ratio
        Image after(primary.width * ratio_d, primary.height * ratio_d);

        // this loop use to get the new primary by resizing the old one
        for (int i = 0; i < after.width; i++) {
            for (int j = 0; j < after.height; j++) {
                after(i, j, 0) = primary(i / ratio_d, j / ratio_d, 0);
                after(i, j, 1) = primary(i / ratio_d, j / ratio_d, 1);
                after(i, j, 2) = primary(i / ratio_d, j / ratio_d, 2);

            }
        }


        asking_for_saving(after, name);


    }

}


void asking_for_saving(Image& primary, string &name){

    // see if user wants to keep filtering or save the primary
    cout<<"Press 1 if you want to save the primary"<<endl;
    cout<<"Press 2 if you want to continue filtering primary"<<endl;
    cout<<"Press 3 if you want to load a new primary"<<endl;
    cout<<"Press 4 if you want to exit"<<endl;
    string choice;
    cin>>choice;
    choice=choice_load_save_2(choice);

    if(choice=="1"){
        cout<<"1. Save Image in same file"<<endl;
        cout<<"2. Save Image in new file"<<endl;
        cout<<"Enter 1 or 2"<<endl;
        string choice_1;
        cin>>choice_1;
        choice_1= choice_load_save(choice_1);
        // save in same file
        if(choice_1=="1"){
            primary.saveImage(name);

            cout<<"Saved Successfully"<<endl;
        }
            // save in new file
        else if(choice_1=="2"){
            cout<<"Enter your new primary name with correct extension"<<endl;
            cout<<".jpg or .bmp or .png or .jpeg: ";
            string Image_name;
            cin>>Image_name;
            Image_name=image_name_validate(Image_name,name);
            primary.saveImage(Image_name);
            cout<<"Saved Successfully"<<endl<<endl;
        }
        cout<<endl<<endl;

        // see if user wants to continue using application
        cout<<"Press 1 if you want to load a new primary"<<endl;
        cout<<"Press 2 if you want to exit"<<endl;
        string choice_2;
        cin>>choice_2;
        choice_2=choice_load_save(choice_2);
        if(choice_2=="1"){
            cin.ignore();
            main();
        }
        else if(choice_2=="2"){
            cout<<"Thanks for using our primary filter application"<<endl;
            exit(0);
        }
    }
    else if(choice=="3"){

        load_image(primary,name);
    }
    else if(choice=="4"){
        save_image(primary,name);
        cout<<"Thanks for using our Photoshop Application"<<endl;
        exit(0);
    }

        // keep filtering
    else{
        filters_menu(primary,name);
    }
}

void add_frame_simple(Image& image, int* frame_color) {
    // Add a simple frame to the primary
    int frame_size = min(image.width, image.height) / 20; // Adjust the frame size as needed
    for (int i = 0; i < image.width; ++i) {
        for (int j = 0; j < image.height; ++j) {
            if (i < frame_size || i >= image.width - frame_size || j < frame_size || j >= image.height - frame_size) {
                // Set the pixel color to the frame color for pixels within the frame border
                for (int k = 0; k < 3; ++k) {
                    image.setPixel(i, j, 0, frame_color[0]);
                    image.setPixel(i, j, 1, frame_color[1]);
                    image.setPixel(i, j, 2, frame_color[2]);
                }
            }
        }
    }
}
void add_frame_arboretum(Image& image, int* frame_color,int* frame_color_2) {
    // Add the outer simple frame
    add_frame_simple(image, frame_color);

    // Add space between the outer and inner frames

    int frame_size = min(image.width, image.height) / 20; // Adjust the frame size as needed
    int space = frame_size/3;
    int inner_frame_size = frame_size - space;

    // Add the inner simple frame
    for (int i = space; i < image.width - space; ++i) {
        for (int j = space; j < image.height - space; ++j) {
            if (i < inner_frame_size || i >= image.width - inner_frame_size || j < inner_frame_size || j >= image.height - inner_frame_size) {
                // Set the pixel color to the frame color for pixels within the inner frame border
                for (int k = 0; k < 3; ++k) {
                    image.setPixel(i, j, 0, frame_color_2[0]); // Red channel
                    image.setPixel(i, j, 1, frame_color_2[1]); // Green channel
                    image.setPixel(i, j, 2, frame_color_2[2]); // Blue channel
                }
            }
        }
    }
}
void circular_frame(Image& image,int *frame_color, int* frame_color_2){
    string x;
    cout<<"Please enter the number of circles you want on the frame"<<endl;
    cout<<"Min is 6, Max is 50"<<endl;
    cin>>x;
    while (true){
        if(!is_number(x) || stoi(x)%2!=0 || stoi(x)<6 || stoi(x)>50){
            cout<<"Please enter even number of circles from 6 to 50"<<endl;
            cin>>x;
        }
        else break;
    }
    int n=stoi(x);
    n>>=1;
    int  n2=(float)n*image.height/image.width;
    n=image.width/n;
    float arcoef =6.283186/n;
    float coef =  1/arcoef;

    n2=image.height/n2;
    float arcoef2 =6.283186/n2;
    float coef2 =  1/arcoef2;

    int sini,sinj;
    for(int i=0;i<image.width;++i){
        for(int j=0;j<image.height;++j){
            sini = sin(i*arcoef)*coef;
            sinj = sin(j*arcoef2)*coef2;
            if(sini>j || -sini>image.height-j || -sinj>i || sinj>image.width-i){
                image(i,j,0)=frame_color[0];
                image(i,j,1)=frame_color[1];
                image(i,j,2)=frame_color[2];
            }
            else if(-sini>j || sini>image.height-j || sinj>i || -sinj>image.width-i){
                image(i,j,0)=frame_color_2[0];
                image(i,j,1)=frame_color_2[1];
                image(i,j,2)=frame_color_2[2];
            }
        }
    }
}
void add_frame_to_image(Image& image,string& name) {
    string frame_type;
    cout<<"Please enter number of desired frame type"<<endl;
    cout<<"1. Simple"<<endl;
    cout<<"2. Arboretum"<<endl;
    cout<<"3. Semicircles"<<endl;
    cout<<"4. Fancy"<<endl;
    cin >> frame_type;
    while(true){
        if(frame_type!="1" && frame_type !="2" && frame_type !="3" && frame_type!="4"){
            cout<<"please enter 1 or 2 or 3 or 4"<<endl;
            cin>>frame_type;
        }
        else break;
    }
    if (frame_type == "1") {
        int frame_color[3]; // Array to store RGB values of frame color
        int *ptr_frame_color = frame_color; // Pointer to frame color array

        cout << "Please enter the color of the frame (RGB values separated by spaces, e.g., '255 0 0' for red): "<<endl;
        for (int i = 0; i < 3; ++i) {
            cout<<"Enter colour number"<<i+1<<endl;
            string x;
            cin>>x;
            while(true){
                if(!is_number(x)|| stoi(x)>255 || stoi(x)<0){
                    cout<<"please enter a valid colour number from 0 to 255"<<endl;
                    cin>>x;
                }
                else{
                    *(ptr_frame_color + i)=stoll(x); // Read RGB values via pointer
                    break;
                }
            }
        }
        add_frame_simple(image, ptr_frame_color);
        asking_for_saving(image,name);
    } else if (frame_type == "2") {
        int frame_color[3]; // Array to store RGB values of frame color
        int *ptr_frame_color = frame_color; // Pointer to frame color array

        cout << "Please enter the primary color of the frame (RGB values separated by spaces, e.g., '255 0 0' for red): "<<endl;
        for (int i = 0; i < 3; ++i) {
            cout<<"Enter colour number"<<i+1<<endl;
            string x;
            cin>>x;
            while(true){
                if(!is_number(x)|| stoi(x)>255 || stoi(x)<0){
                    cout<<"please enter a valid colour number from 0 to 255"<<endl;
                    cin>>x;
                }
                else{
                    *(ptr_frame_color + i)=stoll(x); // Read RGB values via pointer
                    break;
                }
            }
        }
        int frame_color_2[3]; // Array to store RGB values of frame color
        int *ptr_frame_color_2 = frame_color_2; // Pointer to frame color array
        cout << "Please enter the secondary color of the frame (RGB values separated by spaces, e.g., '255 0 0' for red): "<<endl;
        for (int i = 0; i < 3; ++i) {
            cout<<"Enter colour number"<<i+1<<endl;
            string x;
            cin>>x;
            while(true){
                if(!is_number(x)|| stoi(x)>255 || stoi(x)<0){
                    cout<<"please enter a valid colour number from 0 to 255"<<endl;
                    cin>>x;
                }
                else{
                    *(ptr_frame_color_2 + i)=stoll(x); // Read RGB values via pointer
                    break;
                }
            }
        }
        add_frame_arboretum(image, ptr_frame_color,ptr_frame_color_2);
        asking_for_saving(image,name);
    }
    else if(frame_type=="3"){
        int frame_color[3]; // Array to store RGB values of frame color
        int *ptr_frame_color = frame_color; // Pointer to frame color array

        cout << "Please enter the primary color of the frame (RGB values separated by spaces, e.g., '255 0 0' for red): "<<endl;
        for (int i = 0; i < 3; ++i) {
            cout<<"Enter colour number"<<i+1<<endl;
            string x;
            cin>>x;
            while(true){
                if(!is_number(x)|| stoi(x)>255 || stoi(x)<0){
                    cout<<"please enter a valid colour number from 0 to 255"<<endl;
                    cin>>x;
                }
                else{
                    *(ptr_frame_color + i)=stoll(x); // Read RGB values via pointer
                    break;
                }
            }
        }
        int frame_color_2[3]; // Array to store RGB values of frame color
        int *ptr_frame_color_2 = frame_color_2; // Pointer to frame color array
        cout << "Please enter the secondary color of the frame (RGB values separated by spaces, e.g., '255 0 0' for red): "<<endl;
        for (int i = 0; i < 3; ++i) {
            cout<<"Enter colour number"<<i+1<<endl;
            string x;
            cin>>x;
            while(true){
                if(!is_number(x)|| stoi(x)>255 || stoi(x)<0){
                    cout<<"please enter a valid colour number from 0 to 255"<<endl;
                    cin>>x;
                }
                else{
                    *(ptr_frame_color_2 + i)=stoll(x); // Read RGB values via pointer
                    break;
                }
            }
        }
        circular_frame(image,ptr_frame_color,ptr_frame_color_2);
        asking_for_saving(image,name);
    }
    else{
        asking_for_saving(image,name);
    }
}

void detect_edge(Image& primary, string& name){

//     //if the pixel channel color was under 127 make it 0 else make it 255

    for(int i=0; i<primary.width; i++){
        for(int j=0; j<primary.height; j++){
            unsigned int avg = 0;
            for (int k = 0; k < primary.channels; k++)
                avg +=primary(i, j, k);

            avg/=3;
            if(avg >= 128){
                primary(i,j,0) = 255;
                primary(i,j,1) = 255;
                primary(i,j,2) = 255;

            }else{
                primary(i,j,0) = 0;
                primary(i,j,1) = 0;
                primary(i,j,2) = 0;

            }
        }
    }
    // giving user choice between two edge detecting techniques and validating choice
    string choice;
    cout<<"1. Roberts operator technique"<<endl;
    cout<<"2. Sobel operator technique"<<endl;
    cout<<"3. Simple technique"<<endl<<endl;
    cout<<"Enter 1 or 2 or 3"<<endl;
    cin>>choice;
    while(true){
        if(choice=="1")break;
        else if(choice=="2")break;
        else if(choice=="3")break;
        else{
            cout<<"Please enter a valid choice"<<endl;
            cin>>choice;
        }
    }
    // Roberts technique (2*2)
    if(choice=="1"){
        for(int i=1; i<primary.width-1; i++){
            for(int j=1; j<primary.height-1; j++){
                for(int k=0; k<primary.channels; k++){
                    primary(i,j,k)=abs(primary(i,j,k)-primary(i+1,j+1,k))+abs(primary(i,j+1,k)-primary(i+1,j,k));
                }
            }
        }

        // switching black and white
        for(int i=1; i<primary.width-1; i++){
            for(int j=1; j<primary.height-1; j++){
                for(int k=0; k<primary.channels; k++){
                    if(primary(i,j,k)>=127){
                        primary(i,j,k)=0;
                    }
                    else{
                        primary(i,j,k)=255;
                    }
                }
            }
        }
        asking_for_saving(primary,name);
    }
        // Sobel technique (3*3) gradient
    else if(choice=="2"){
        Image secondary(primary.width, primary.height);
        for (int i = 1; i < primary.width - 1; i++) {
            for (int j = 1; j < primary.height - 1; j++) {
                for (int k = 0; k < primary.channels; k++) {
                    secondary(i, j, k) = abs(primary(i + 1, j - 1, k) + 2 * primary(i + 1, j, k) + primary(i + 1, j + 1, k)
                                             - primary(i - 1, j - 1, k) - 2 * primary(i - 1, j, k) - primary(i - 1, j + 1, k))
                                         + abs(primary(i - 1, j + 1, k) + 2 * primary(i, j + 1, k) + primary(i + 1, j + 1, k)
                                               - primary(i - 1, j - 1, k) - 2 * primary(i, j - 1, k) - primary(i + 1, j - 1, k));
                }
            }
        }
        // switching black and white
        for(int i=0; i<secondary.width; i++){
            for(int j=0; j<secondary.height; j++){
                for(int k=0; k<secondary.channels; k++){
                    if(secondary(i,j,k)==0){
                        secondary(i,j,k)=255;
                    }
                    else{
                        secondary(i,j,k)=0;
                    }
                }
            }
        }
        asking_for_saving(secondary,name);
    }
    else{
        Image secondary(primary.width, primary.height);

        // checking neighbouring pixels (up,right,left,down) if they are white then consider it an edge if the pixel is black, else it is white
        for(int i=1; i<primary.width-1; i++){
            for(int j=1; j<primary.height-1; j++){
                if((primary(i+1,j,0)==255 || primary(i-1,j,0)==255 || primary(i,j+1,0)==255 || primary(i,j-1,0)==255 || primary(i+1,j+1,0)==255 || primary(i+1,j-1,0)==255 || primary(i-1,j+1,0)==255 || primary(i-1,j-1,0)==255) && primary(i,j,0)==0){
                    secondary(i,j,0)=0;
                    secondary(i,j,1)=0;
                    secondary(i,j,2)=0;

                }
                else{
                    secondary(i,j,0)=255;
                    secondary(i,j,1)=255;
                    secondary(i,j,2)=255;
                }
            }
        }


        asking_for_saving(secondary,name);
    }

}

void crop(Image& primary, string &name){

// Declare variables for the scale and dimensions

    string scale, choice;
    int ht, wd;
    smatch matches;
    do{
        // get the choice if it from left or right or middle
        cout << "please select"<<endl<<"1 to crop at middle"<<endl<<"2 to crop from top-left"<<endl<< "3 to crop from down-left"<<endl<<"4 to cut from top-right"<<endl<<"5 cut from down-right"<<endl;
        cout << "Enter your choice: "<<endl;
        cin >> choice;
        if(!(choice == "1" || choice == "2" || choice == "3" || choice == "4" || choice == "5")){
            cout << "Invalid input" << endl;
        }
    }while(!(choice == "1" || choice == "2" || choice == "3" || choice == "4" || choice == "5"));

// Define a regex pattern for matching the scale format (width*height)
    regex pattern(R"((\d+)\*(\d+))");

// Declare variables for the width and height scale factors
    int width_scale, height_scale;

// Use a do-while loop to repeatedly prompt the user for input until a valid scale is entered
    cin.ignore();
    do {
        // Prompt the user to enter the scale
        cout << "Enter the size you want in (format: width*height): "<<endl;
        getline(cin,scale);

        // Check if the input matches the regex pattern
        if (!regex_search(scale, pattern)) {
            // If the input does not match the pattern, print an error message and continue the loop
            cout << "Invalid input format" << endl;
            continue;
        }

        // Extract the width and height substrings from the input
        regex_search(scale, matches, pattern);

        // Convert the width and height substrings to integers
        width_scale = stoi(matches[1]);
        height_scale = stoi(matches[2]);

        // Check if the width and height scale factors are positive integers
        if (width_scale <= 0 || height_scale <= 0 || height_scale > primary.height || width_scale > primary.width) {
            // If the width or height scale factor is not a positive integer, print an error message
            cout << "Invalid input: width and height must be positive integers" << endl;
        }
        // Continue the loop until a valid scale is entered
    } while (width_scale <= 0 || height_scale <= 0 || height_scale > primary.height || width_scale > primary.width);
// get the new primary depend on the scale input
    Image after ( width_scale, height_scale);

    if(choice == "1"){

        long long width_point, height_point;
        string point;


        do {
            // Prompt the user to enter the scale
            cout << "Enter the starting point you want in (format: width*height): "<<endl;
            getline(cin,point);
            // Check if the input matches the regex pattern
            if (!regex_search(point, pattern)) {
                // If the input does not match the pattern, print an error message and continue the loop
                cout << "Invalid input format" << endl;
                continue;
            }

            regex_search(point, matches,pattern);
            // Convert the width point, and height point substrings to integers
            width_point = stoi(matches[1]);
            height_point = stoi(matches[2]);



            if (width_point < 0 || height_point < 0 || height_point > primary.height || width_point > primary.width) {
                cout << "Invalid input. please enter a positive number" << endl;

            }
            if ((primary.width - width_point - width_scale) <= 0 || (primary.height - height_point - height_scale) <= 0){

                cout << "Invalid input. please enter a valid staring points" << endl;

            }
            // Continue the loop until a valid input is entered
        } while (width_point < 0 || height_point < 0 || height_point > primary.height || width_point > primary.width || (primary.width - width_point - width_scale) <= 0 || (primary.height - height_point - height_scale) <= 0);



        for (long long i = width_point ; i < (width_point + width_scale) ; i++) {
            for (long long j = height_point ; j < (height_point + height_scale) ; j++) {
                after(i - width_point, j - height_point, 0) = primary(i, j, 0);
                after(i - width_point, j - height_point, 1) = primary(i, j, 1);
                after(i - width_point, j - height_point, 2) = primary(i, j, 2);


            }

        }







    }else if (choice == "2"){
        // crop at top-left
        for (int i = 0; i < width_scale; i++) {
            for (int j = 0; j < height_scale; j++) {
                after(i, j, 0) = primary(i, j, 0);
                after(i, j, 1) = primary(i, j, 1);
                after(i, j, 2) = primary(i, j, 2);

            }
        }

    }else if (choice == "3"){
        // crop at down-left
        for (int i = 0; i < width_scale; i++) {
            for (int j = height_scale; j > 0; j--) {

                after(i, j % height_scale, 0) = primary(i, j, 0);
                after(i, j % height_scale, 1) = primary(i, j, 1);
                after(i, j % height_scale, 2) = primary(i, j, 2);

            }
        }

    }else if (choice == "4"){
        // crop at top-right
        for (int i = width_scale; i > 0 ; i--) {
            for (int j = 0; j < height_scale; j++) {
                after(i % width_scale, j, 0) = primary(i, j, 0);
                after(i % width_scale, j, 1) = primary(i, j, 1);
                after(i % width_scale, j, 2) = primary(i, j, 2);

            }
        }

    }else if (choice == "5"){
        // crop at down-right
        for (int i = width_scale; i > 0 ; i--) {
            for (int j = height_scale; j > 0; j--) {
                after(i % width_scale, j % height_scale, 0) = primary(i, j, 0);
                after(i % width_scale, j % height_scale, 1) = primary(i, j, 1);
                after(i % width_scale, j % height_scale, 2) = primary(i, j, 2);

            }
        }

    }


    asking_for_saving(after, name);


}



void flip(Image& primary, string &name){
    string choice;
    Image after(primary.width, primary.height);

    do {
        cout << "Choose\n1 to vertical flip\n2 to horizontal flip" << endl;
        cin >> choice;
        if(!(choice == "1" || choice == "2")){
            cout << "Invalid input" << endl;
        }
    } while (!(choice == "1" || choice == "2"));
    if (choice == "1"){
        // vertical flip
        for (int i = 0; i < primary.width; i++) {
            for (int j = primary.height - 1; j >= 0; j--) {
                after(i, j, 0) = primary(i, primary.height - 1 - j, 0);
                after(i, j, 1) = primary(i, primary.height - 1 - j, 1);
                after(i, j, 2) = primary(i, primary.height - 1 - j, 2);
            }
        }

    }else{
        // horizontal flip
        for (int i = 0; i < primary.width; i++) {
            for (int j = 0; j < primary.height; j++) {
                after(i, j, 0) = primary(primary.width - 1 - i, j, 0);
                after(i, j, 1) = primary(primary.width - 1 - i, j, 1);
                after(i, j, 2) = primary(primary.width - 1 - i, j, 2);
            }
        }
    }
    asking_for_saving(after, name);

}

// load function
void load_image(Image& primary, string& name) {
    // check if user wants to save previous primary or not
    cout << "Would You like to save primary before loading a new one?" << endl;
    cout << "1. Yes" << endl;
    cout << "2. No" << endl;

    // validate choice
    string choice;
    cin >> choice;
    choice=choice_load_save(choice);

    // save primary in same file or new file
    if (choice == "1") {
        cout << "1. Save Image in same file" << endl;
        cout << "2. Save Image in new file" << endl;
        cout << "Enter 1 or 2" << endl;
        string choice_1;
        cin >> choice_1;
        choice_1 = choice_load_save(choice_1);
        // save in same file
        if (choice_1 == "1") {
            primary.saveImage(name);

            cout << "Saved Successfully" << endl;
        }
            // save in new file
        else if (choice_1 == "2") {
            cout << "Enter your new primary name with correct extension" << endl;
            cout << ".jpg or .bmp or .png or .jpeg: ";
            string Image_name;
            cin >> Image_name;
            Image_name = image_name_validate(Image_name, name);
            primary.saveImage(Image_name);
            cout << "Saved Successfully" << endl << endl;
        }
    }
    // load new primary
    cin.ignore();
    cout << endl << endl;
    cout << "Load your primary" << endl;
    cout << "Enter your primary name with a correct extension" << endl;
    cout << ".jpg or .bmp or .png or .jpeg: "<<endl;
    string image_name;
    getline(cin, image_name);

    // make sure that the primary is in the directory
    while (true) {
        try {
            primary.loadNewImage(image_name);
            cout << "Loaded successfully" << endl;
            cout << endl;
            break;

        }
        catch (const invalid_argument &e) {
            cout << "Enter a correct primary name with correct extension" << endl;
            cout << ".jpg or .bmp or .png or .jpeg" << endl;
            getline(cin, image_name);
        }
    }
    filters_menu(primary, image_name);
}

void save_image(Image& primary,string& name){
    // check if user wants to save previous primary or not
    cout << "Would You like to save primary?" << endl;
    cout << "1. Yes" << endl;
    cout << "2. No" << endl;

    // validate choice
    string choice;
    cin >> choice;
    choice=choice_load_save(choice);

    // save primary in same file or new file
    if (choice == "1") {
        cout << "1. Save Image in same file" << endl;
        cout << "2. Save Image in new file" << endl;
        cout << "Enter 1 or 2" << endl;
        string choice_1;
        cin >> choice_1;
        choice_1 = choice_load_save(choice_1);
        // save in same file
        if (choice_1 == "1") {
            primary.saveImage(name);

            cout << "Saved Successfully" << endl;
        }
            // save in new file
        else if (choice_1 == "2") {
            cout << "Enter your new primary name with correct extension" << endl;
            cout << ".jpg or .bmp or .png or .jpeg: "<<endl;
            string Image_name;
            cin >> Image_name;
            Image_name = image_name_validate(Image_name, name);
            primary.saveImage(Image_name);
            cout << "Saved Successfully" << endl << endl;
        }
    }
}


void purple(Image& primary, string& name) {
    int degree = 0;
    bool valid_input = false;
    while (!valid_input) {
        cout << "Enter the purple degree that you want (20:50):" << endl;
        if (cin >> degree) {
            if (degree > 50 || degree <= 20) {
                cout << "Invalid input. Please enter a value between 20 and 50." << endl;
                continue;
            } else {
                valid_input = true;
            }
        } else {
            cout << "Invalid input. Please enter an integer value." << endl;
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
    }
    // Iterate through each pixel
    for (int y = 0; y < primary.height; y++) {
        for (int x = 0; x < primary.width; x++) {
            // Get the original color
            unsigned char red = primary(x, y, 0);
            unsigned char green = primary(x, y, 1);
            unsigned char blue = primary(x, y, 2);

            // Apply the purple filter by increasing the red and blue channels and decreasing the green channel
            primary(x, y, 0) = min(255, red + degree); // increase red channel
            primary(x, y, 1) = max(0, green - (degree + 15)); // decrease green channel
            primary(x, y, 2) = min(255, blue + degree); // increase blue channel
        }
    }

    // Save the primary with the purple filter applied
    asking_for_saving(primary, name);

    // Save the primary with the purple filter applied
}
void blurImage(Image& primary, string& name) {
    int width = primary.width;
    int height = primary.height;
    // Resize the primary to 750x750
    double h = (750.0 / 1.0) / (height / 1.0);
    double w = (750.0 / 1.0) / (width / 1.0);
    Image after(750, 750);
    for (int i = 0; i < after.width; i++) {
        for (int j = 0; j < after.height; j++) {
            after(i, j, 0) = primary(i / w, j / h, 0);
            after(i, j, 1) = primary(i / w, j / h, 1);
            after(i, j, 2) = primary(i / w, j / h, 2);
        }
    }
    // making blur for resized photo
    int width_2 = after.width;
    int height_2 = after.height;
    int kernelSize = 5; // size of blur degree
    int iterations = 3; // Number of blur iterations

    for (int iter = 0; iter < iterations; iter++) {
        for (int i = 0; i < width_2; i++) {
            for (int j = 0; j < height_2; j++) {
                for (int k = 0; k < after.channels; k++) {
                    int sum = 0;
                    int count = 0;
                    for (int m = -kernelSize; m <= kernelSize; m++) { /// iterate from -5  and 5
                        for (int n = -kernelSize; n <= kernelSize; n++) { /// iterate from -5  and 5
                            int x = i + m;
                            int y = j + n;

                            // Boundary checks corrected
                            if (x >= 0 && x < width_2 && y >= 0 && y < height_2) {
                                sum += after(x, y, k);
                                count++;
                            }
                        }
                    }
                    int average = sum / count;
                    after(i, j, k) = average;
                }
            }
        }
    }
    // return the basic photo after making blur
    for (int i = 0; i < primary.width; i++) {
        for (int j = 0; j < primary.height; j++) {
            primary(i, j, 0) = after(i * w, j * h, 0);
            primary(i, j, 1) = after(i * w, j * h, 1);
            primary(i, j, 2) = after(i * w, j * h, 2);
        }
    }

    // Save the blurred primary
    asking_for_saving(primary, name);
}

void sunny_filter(Image& primary, string& name) {
    int degree;
    bool valid_input = false;

    while (!valid_input) {
        cout << "Enter the yellow percentage degree that you want (0:100): "<<endl;
        if (cin >> degree && degree > 0 && degree <= 100) {
            valid_input = true;
        } else {
            cout << "Invalid input. Please enter a value between 0 and 100." << endl;
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
    }

    for (int i = 0; i < primary.width; i++) {
        for (int j = 0; j < primary.height; j++) {
            unsigned char red = primary(i, j, 0);
            unsigned char green = primary(i, j, 1);
            unsigned char blue = primary(i, j, 2);

            // Apply the yellow filter by increasing the red and green channels and decreasing the blue channel
            primary(i, j, 0) = min(255, red + degree); // increase red channel
            primary(i, j, 1) = min(255, green + degree); // increase green channel
            primary(i, j, 2) = max(0, blue - degree); // decrease blue channel
        }
    }

    asking_for_saving(primary, name);
}

bool is_number(string x){
    for(int i=0; i<x.length(); i++){
        if(!isdigit(x[i])){
            return false;
        }
    }
    return true;
}

void Ball(Image& primary,string &name){
    Image image2((primary.width > primary.height)?primary.height:primary.width,
                 (primary.width > primary.height)?primary.height:primary.width);

    // assign the half radius
    int r = 0.5 * image2.width;

    for (int i = 0; i < image2.width; ++i) {
        for (int j = 0; j < image2.height; ++j) {
            double ball = (sqrt((r * r  - (i - r)*(i - r)  - (j - r)*(j - r) )) / r);
            image2(i, j, 0) = primary(i, j, 0) * ball;
            image2(i, j, 1) = primary(i, j, 1) * ball;
            image2(i, j, 2) = primary(i, j, 2) * ball;
        }
    }
    asking_for_saving(image2,name);
}

void Pixelate(Image& primary,string &name){
    // the following variable take number from 1 to 200 percentage from total pixels of image
    cout<<"Please enter slide_value from 1 to 200: "<<endl;
    string SlideValue;
    cin>>SlideValue;
    while(true){
        if(!is_number(SlideValue)|| stoi(SlideValue)>200 || stoi(SlideValue)<1){
            cout<<"please enter a number from 1 to 200 "<<endl;
            cin>>SlideValue;
        }
        else{
            break;
        }
    }
    //that means if we set it 1000 it will get the pixels that it is average of all pixels
    // try more than value to understand
    Image image(primary);
    ll value=stoll(SlideValue);
    int b = (value/1000.0)*((image.width < image.height)? image.height: image.width);
    for(int i=0;i<image.width;i+=b){
        for(int j=0;j<image.height;j+=b){
            int R=0,G=0,B=0,k = 0, l = 0;
            for(;(k<b)&&(i+k<image.width);++k){
                for(;(l<b) && (l+j<image.height);++l) {
                    R += image(i + k, j + l, 0);
                    G += image(i + k, j + l, 1);
                    B += image(i + k, j + l, 2);
                }
            }
            R/=  l ;
            G/=  l ;
            B/=  l ;
            for(int k=i;((k<i+b))&&(k<image.width);++k){
                for(int l=j;((l<j+b))&&(l<image.height);++l){
                    image(k,l,0)=R;
                    image(k,l,1)=G;
                    image(k,l,2)=B;
                }
            }
        }
    }
    asking_for_saving(image,name);
}
int square(int x){return x*x;}
void rain_drop(Image& image, string& name){
    float coef = 100.0/((image.width<image.height)?image.width:image.height);
    for(int i=0;i<image.width;++i){
        for(int j=0;j<image.height;++j){
            float c = coef * (sqrt(square(i-image.width/2)+ square(j-image.height/2)));
            float z = .8 *( sin(c)/c + 0.24);
            image(i,j,0) = (image(i,j,0)*z*3 >255)? 255:image(i,j,0)*z*3;
            image(i,j,1) = (image(i,j,0)*z*3 >255)? 255:image(i,j,1)*z*3;
            image(i,j,2) = (image(i,j,0)*z*3 >255)? 255:image(i,j,2)*z*3;
        }
    }
    asking_for_saving(image,name);
}
void skew(Image& image,string& name){
    cout<<"Please enter angle between -90 to 90 other than zero"<<endl;
    double angle=getValidFloatInput();
    if(angle<0){
        //the angle for skewing
        double ang=abs(angle);
        ang=((ang)/180)*3.1416;
        double slop=tan(ang);
        Image image2(image.width + image.height * cos(ang),image.height * sin(ang));
        //To print whole the height
        double n = (float)image.height / image2.height;
//skewed by one loop
        for(int i=0;i<image2.width;++i){
            for(int j=0;j<image2.height;++j){
// we used adea of flip vertical that the library design depend on it. we made an equation for two straight lines -ve slop and fill the determinant part.
                if((j>image2.height-slop*i) && ((j<image2.height -slop*(i - image.width)))){
                    image2(i,j,0) = image(i-(image2.height-j)/slop,j*n,0);
                    image2(i,j,1) = image(i-(image2.height-j)/slop,j*n,1);
                    image2(i,j,2) = image(i-(image2.height-j)/slop,j*n,2);
                }
            }
        }
        asking_for_saving(image2,name);
    }
    else{
        double ang=angle;
        ang = (ang/180) * 3.1416;
        double slop = tan(ang);
        Image image2(image.width + image.height * cos(ang),image.height * sin(ang));
        double n = (float)image.height/image2.height;
        for(int i=0;i<image2.width;++i){
            for(int j=0;j<image2.height;++j){
                if((j<i*slop) && (j>slop*(i-image.width))){
                    image2(i,j,0)=image((i-j/slop),j*n,0);
                    image2(i,j,1)=image((i-j/slop),j*n,1);
                    image2(i,j,2)=image((i-j/slop),j*n,2);
                }
            }
        }
        asking_for_saving(image2,name);
    }
}
void resize2_image(int new_width ,int new_height,Image& primary) {
    double x = double(primary.width) / new_width;
    double y = double(primary.height) / new_height;
    Image resized(new_width, new_height);
    for (int i = 0; i < new_width; ++i) {
        for (int j = 0; j < new_height; ++j) {
            for (int k = 0; k < 3; ++k) {
                resized(i, j, k) = primary(floor(i * x), floor(j * y), k);
            }
        }
    }
    primary.~Image();
    primary = resized;
}
void oil_painting(Image& primary,string& name){
    int width = primary.width;
    int height = primary.height ;
    if (width > 1000 || height > 1000){
        resize2_image(1000,1000,primary);
    }
    double intensity_level = 5; // Intensity levels used for effect
    int radius = 2; // Radius of 2 for 5x5 neighborhood
    int intensity_size = 256; // Maximum intensity value (0-256)

    for (int i = radius; i < primary.width - radius; ++i) {
        for (int j = radius; j < primary.height - radius; ++j) {

            vector<int> cur_intensity_count(intensity_size, 0);
            vector<int> average_R(intensity_size, 0);
            vector<int> average_G(intensity_size, 0);
            vector<int> average_B(intensity_size, 0);

            for (int k = i - radius; k <= i + radius; ++k) {
                for (int l = j - radius; l <= j + radius; ++l) {
                    // Calculate intensity for the current pixel
                    int R = primary(k, l, 0);
                    int G = primary(k, l, 1);
                    int B = primary(k, l, 2);
                    int cur_intensity = (int)((double)((R + G + B) / 3) * intensity_level) / 255;

                    // Safeguard for intensity bounds
                    cur_intensity = max(0, min(255, cur_intensity));

                    // Update intensity count and sum of RGB values
                    cur_intensity_count[cur_intensity]++;
                    average_R[cur_intensity] += R;
                    average_G[cur_intensity] += G;
                    average_B[cur_intensity] += B;
                }
            }

            // Find the intensity with the maximum count
            int mx_intensity_count = 0, mx_intensity_index = 0;
            for (int M = 0; M < intensity_size; ++M) {
                if (cur_intensity_count[M] > mx_intensity_count) {
                    mx_intensity_count = cur_intensity_count[M];
                    mx_intensity_index = M;
                }
            }

            // Assign the average RGB values to the output image
            if (mx_intensity_count > 0) {
                primary(i, j, 0) = average_R[mx_intensity_index] / mx_intensity_count;
                primary(i, j, 1) = average_G[mx_intensity_index] / mx_intensity_count;
                primary(i, j, 2) = average_B[mx_intensity_index] / mx_intensity_count;
            }
        }
    }
    resize2_image(width,height,primary);
    asking_for_saving(primary,name);
}
float getValidFloatInput() {
    float input;
    while (true) {
        cin >> input;
        // Check if the input is valid
        if (cin.fail()) {
            cin.clear(); // Clear the error flag
            cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Discard invalid input
            cout << "Invalid input. Please enter a valid float value." << std::endl;
        }
        else if(input<-90 || input>90 || input==90 || input==-90 || input==0){
            cout << "Enter an angle between -90 to 90 other than zero: "<<endl;
        }
        else {
            cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Clear any extra input
            return input; // Valid float input
        }
    }
}

void Egg(Image& image,string &name){
    Image image2(image.width,image.height);
    int a=image.width>>1;
    int b=image.height>>1;
    float a2=a*a;
    float b2=b*b;
    float d,d2;
    for(int i=0;i<image.width;++i){
        d=image.height*sqrt(1-(i-a)/a2);
        for(int j=0;j<image.height;++j){
            if(square(j-b)/b2 + square(i-a)/a2 >1){
                image2(i,j,0)=0;
                image2(i,j,1)=0;
                image2(i,j,2)=0;
            }
            else{
                if(d)
                    d2=(j+(b* sqrt(1- square(i-a)/a2)-b))/d;
                image2(i,j,0)=image(i,d2*image.height,0);
                image2(i,j,1)=image(i,d2*image.height,1);
                image2(i,j,2)=image(i,d2*image.height,2);
            }
        }
    }
    asking_for_saving(image2,name);
}
void Cardiod(Image& image2,string &name){
    Image image(1000,1000);
    double d1=image2.width/1000.0;
    double d2=image2.height/1000.0;
    float angle=45;
    angle = angle*3.1415927/180;
    float angle2=315;
    angle2 = angle2*3.1415927/180;
    float cosAng = cos(angle);
    float sinAng = sin(angle);
    float cosAng2 = cos(angle2);
    float sinAng2 = sin(angle2);
    float k,k2;
    for(float i=0;i<1000;++i){
        for(float j=0;j<1000;++j){
            if(0.7*square(i-500) + square((575-j)- 13.416*sqrt(abs(i-500))) >175000 ){
                k=0.7*square(cosAng*(i-150)+sinAng*(j-850)) + square((sinAng*(i-150)+cosAng*(850-j))- 4*sqrt(abs(cosAng*(i-150)+sinAng*(j-850))));
                k2=0.7*square(cosAng2*(i-850)+sinAng2*(j-850)) + square((sinAng2*(i-850)+cosAng2*(850-j))- 4*sqrt(abs(cosAng2*(i-850)+sinAng2*(j-850))));
                //Each the if statement has variable k belongs to the first heart with left and versa with k2
                if(k <500) {
                    image(i, j, 0) = 200;
                    image(i, j, 1) = 185;
                    image(i, j, 2) = 255;
                }
                else if(k <1000) {
                    image(i, j, 0) = 255;
                    image(i, j, 1) = 70;
                    image(i, j, 2) = 180;
                }
                else if(k<2000){
                    image(i, j, 0) = 255;
                    image(i, j, 1) = 0;
                    image(i, j, 2) = 100;
                }
                else if(k<3000){
                    image(i, j, 0) = 255;
                    image(i, j, 1) = 0;
                    image(i, j, 2) = 10;
                }
                else if(k<4000){
                    image(i, j, 0) = 255 ;
                    image(i, j, 1) = 105;
                    image(i, j, 2) = 33;
                }
                else if(k<5000){
                    image(i, j, 0) = 255;
                    image(i, j, 1) = 120;
                    image(i, j, 2) = 50;
                }

                else if(k2 <500) {
                    image(i, j, 0) = 200;
                    image(i, j, 1) = 185;
                    image(i, j, 2) = 255;
                }
                else if(k2 <1000) {
                    image(i, j, 0) = 255;
                    image(i, j, 1) = 70;
                    image(i, j, 2) = 180;
                }
                else if(k2<2000){
                    image(i, j, 0) = 255;
                    image(i, j, 1) = 0;
                    image(i, j, 2) = 100;
                }
                else if(k2<3000){
                    image(i, j, 0) = 255;
                    image(i, j, 1) = 0;
                    image(i, j, 2) = 10;
                }
                else if(k2<4000){
                    image(i, j, 0) = 255 ;
                    image(i, j, 1) = 105;
                    image(i, j, 2) = 33;
                }
                else if(k2<5000){
                    image(i, j, 0) = 255;
                    image(i, j, 1) = 120;
                    image(i, j, 2) = 50;
                }
                    //this color the big background
                else{
                    image(i,j,0)=255;
                    image(i,j,1)=255;
                    image(i,j,2)=255;
                }

            }
                //to fill the image
            else{
                image(i,j,0)=image2(i*d1,j*d2,0);
                image(i,j,1)=image2(i*d1,j*d2,1);
                image(i,j,2)=image2(i*d1,j*d2,2);
            }
        }
    }
    asking_for_saving(image,name);
}

void center_light(Image& image,string & name){
    //This variable that take the value
    float input;
    while (true) {
        cout << "Enter a float number between 0.5 and 2: "<<endl;
        cin >> input;

        // Check for invalid input or if input is out of range
        if (std::cin.fail()) {
            std::cin.clear(); // Clear the error flag
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Discard invalid input
            cout << "Invalid input. Please enter a valid float number." << std::endl;
        } else if (!validate_center_light(input)) {
            cout << "Input out of range. Please enter a number between 0.5 and 2." << std::endl;
        } else {
            break;
        }
    }
    float c=input;

    int a= image.width>>1;
    int b= image.height>>1;
    float A= image.width * 0.707107;
    float B= image.height * 0.707107;
    A*=A;
    B*=B;
    float z;
    for(int i=0;i<image.width;++i){
        for(int j=0;j<image.height;++j){
            z=c*sqrt(1- square(i-a)/A - square(j-b)/B);
            image(i,j,0)=(image(i,j,0)*z>255)?255:image(i,j,0)*z;
            image(i,j,1)=(image(i,j,1)*z>255)?255:image(i,j,1)*z;
            image(i,j,2)=(image(i,j,2)*z>255)?255:image(i,j,2)*z;
        }
    }
    asking_for_saving(image,name);
}
bool validate_center_light(float num) {
    // Check if the number is in the valid range
    return (num >= 0.5f && num <= 2.0f);
}

void rotate_frame(Image& image, string &name){
    float input;

    while (true) {
        std::cout << "Enter a float number between -45 and 45: "<<endl;
        std::cin >> input;

        // Check for invalid input or if input is out of range
        if (std::cin.fail()) {
            std::cin.clear(); // Clear the error flag
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Discard invalid input
            std::cout << "Invalid input. Please enter a valid float number." << std::endl;
        } else if (!validate_rotate_frame(input)) {
            std::cout << "Input out of range. Please enter a number between -45 and 45." << std::endl;
        } else {
            break;
        }
    }
    float ang=input;
    if(ang<0) {
        if (image.height >= image.width) {
            ang = abs(ang);
            ang = ang * 3.141593 / 180;
            float slope = tan(1.570796 - ang);
            float slope2 = -1 / slope;
            int y = image.width * sin(ang);
            int x = (image.height - y) / slope;
            int d1 = image.height - y;
            for (int i = 0; i < image.width; ++i) {
                for (int j = 0; j < image.height; ++j) {
                    if (j > slope * i + y || j < slope * (i - image.width + x) || j < slope2 * i + y ||
                        j > slope2 * (i - image.width) + d1) {
                        image(i, j, 0) = 0;
                        image(i, j, 1) = 0;
                        image(i, j, 2) = 0;
                    }
                }
            }
        }
        else{
            ang = -ang * 3.1415927 / 180;
            int y = image.width * sin(ang);
            float slope = tan(ang);
            float slope2 = -1 / slope;
            for (int i = 0; i < image.width; ++i) {
                for (int j = 0; j < image.height; ++j) {
                    if (j < slope * (-i + image.width - y) || j < slope2 * (-i + image.width - y) ||
                        j > slope * (y - i) + image.height || j > slope2 * (y - i) + image.height) {
                        image(i, j, 0) = 100;
                        image(i, j, 1) = 100;
                        image(i, j, 2) = 100;
                    }
                }
            }
        }
    }
    else {
        if (image.height >= image.width) {
            ang = ang * 3.141593 / 180;
            float slope = tan(ang);
            float slope2 = -1 / slope;
            int y = image.width * sin(ang);
            int x = (image.height - y) * slope;
            for (int i = 0; i < image.width; ++i) {
                for (int j = 0; j < image.height; ++j) {
                    if (j > slope2 * (i - image.width) + y || j < slope2 * i + image.height - y ||
                        j > slope * i + image.height - y || j < slope * (i - image.width) + y) {
                        image(i, j, 0) = 0;
                        image(i, j, 1) = 0;
                        image(i, j, 2) = 0;
                    }
                }
            }
        }
        else{
            ang = ang * 3.1415927 / 180;
            int y = image.width * sin(ang);
            float slope = tan(ang);
            float slope2 = -1 / tan(ang);
            for (int i = 0; i < image.width; ++i) {
                for (int j = 0; j < image.height; ++j) {
                    if (j < slope * (i - y) || j < slope2 * (i - y) ||
                        j > slope * (i - image.width + y) + image.height ||
                        j > slope2 * (i - image.width + y) + image.height) {
                        image(i, j, 0) = 0;
                        image(i, j, 1) = 100;
                        image(i, j, 2) = 255;
                    }
                }
            }
        }
    }
    asking_for_saving(image,name);
}

bool validate_rotate_frame(float num) {
    // Check if the number is in the valid range
    return (num >= -45.0f && num <= 45.0f);
}
void TV(Image& image,string &name){
    cout<<"Please enter 1 or 2 "<<endl;
    cout<<"1. Vintage screen"<<endl;
    cout<<"2. Lost signal screen"<<endl;
    string choice;
    cin>>choice;
    while(true){
        if(choice!="1" && choice!="2"){
            cout<<"Please enter 1 or 2 "<<endl;
            cin>>choice;
        }
        else break;
    }
    if(choice=="1") {
        float coef;
        for (int i = 0; i < image.height; ++i) {
            coef = 3 * abs(0.3 * sin(i));
            for (int j = 0; j < image.width; ++j) {
                image(j, i, 0) = (image(j, i, 0) * coef > 255) ? 255 : image(j, i, 0) * coef;
                image(j, i, 1) = (image(j, i, 0) * coef > 255) ? 255 : image(j, i, 0) * coef;
                image(j, i, 2) = (image(j, i, 0) * coef > 255) ? 255 : image(j, i, 0) * coef;
            }
        }
        asking_for_saving(image, name);
    }
    else{
        int numbers[] = {0, 255,127, 7, 7, 7, 7, 7}; // Your predefined set of values
        int array_size = sizeof(numbers) / sizeof(numbers[0]);
        if(image.width >= 3000 || image.height >= 3000){
            // Seed the random number generator once
            srand(time(0));

            // Loop through the pixels of the image
            for (int i = 0; i < image.width; i+=3) {
                for (int j = 0; j < image.height; j+=3) {
                    // Generate a random index to pick from the numbers array
                    if (i >= image.width || j >= image.height){
                        break;
                    }
                    int random_index = rand() % array_size;
                    int random_number = numbers[random_index];

                    // Set the pixel color (R, G, B) only if the random number is not 7
                    if (random_number != 7) {
                        for (int k = i; k < i+3; ++k) {
                            for (int l = j; l < j+3; ++l) {
                                if (k >= image.width || l >= image.height){
                                    break;
                                }
                                image(k, l, 0) = random_number; // Red channel
                                image(k, l, 1) = random_number; // Green channel
                                image(k, l, 2) = random_number; // Blue channel
                            }
                        }
                    }
                }
            }
        }
        else{
            // Seed the random number generator once
            srand(time(0));

            // Loop through the pixels of the image
            for (int i = 0; i < image.width; ++i) {
                for (int j = 0; j < image.height; ++j) {
                    // Generate a random index to pick from the numbers array
                    int random_index = rand() % array_size;
                    int random_number = numbers[random_index];

                    // Set the pixel color (R, G, B) only if the random number is not 7
                    if (random_number != 7) {
                        image(i, j, 0) = random_number; // Red channel
                        image(i, j, 1) = random_number; // Green channel
                        image(i, j, 2) = random_number; // Blue channel
                    }
                }
            }
        }
    }
}
